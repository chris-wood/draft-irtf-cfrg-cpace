



Network Working Group                                         M. Abdalla
Internet-Draft                       DI, École Normale Supérieure, Paris
Intended status: Informational                                  B. Haase
Expires: 7 May 2022                     Endress + Hauser Liquid Analysis
                                                                J. Hesse
                                         IBM, Zürich Research Laboratory
                                                         3 November 2021


                   CPace, a balanced composable PAKE
                      draft-irtf-cfrg-cpace-latest

Abstract

   This document describes CPace which is a protocol for two parties
   that share a low-entropy secret (password) to derive a strong shared
   key without disclosing the secret to offline dictionary attacks.
   This method was tailored for constrained devices, is compatible with
   any group of both prime- and non-prime order, and comes with a
   security proof providing composability guarantees.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Crypto Forum Research
   Group mailing list (cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=cfrg.

   Source for this draft and an issue tracker can be found at
   https://github.com/chris-wood/draft-irtf-cfrg-cpace.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 7 May 2022.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Requirements Notation
   3.  Definition CPace
     3.1.  Setup
     3.2.  Inputs
     3.3.  Notation
     3.4.  Protocol Flow
     3.5.  CPace
   4.  Ciphersuites
   5.  Use of the hash function in CPace
   6.  CPace on single-coordinate Ladders on Montgomery curves
   7.  CPace on prime-order group abstractions
   8.  Security Considerations
   9.  IANA Considerations
   10. Acknowledgements
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Authors' Addresses

1.  Introduction

   This document describes CPace which is a protocol for two parties
   that share a low-entropy secret (password) to derive a to derive a
   strong shared key without disclosing the secret to offline dictionary
   attacks.

   The CPace method was tailored for constrained devices and
   specifically considers efficiency and hardware side-channel attack
   mitigations at the protocol level.  CPace is designed to be
   compatible with any group of both prime- and non-prime order and
   explicitly handles the complexity of cofactor clearing on the protcol
   level.  CPace comes with game-based and simulation based proofs where
   the latter provides composability guarantees.  As a protocol, CPace
   is designed to be compatible with so-called "x-coordinate-only"
   Diffie-Hellman implementations on elliptic curve groups.

   CPace is designed to be suitable as both, a building block within a
   larger protocol construction using CPace as substep, and as a
   standalone protocol.

   It is considered, that for composed larger protocol constructions,
   the CPace subprotocol might be best executed in a separate
   cryptographic hardware, such as secure element chipsets.  The CPace
   protocol design aims at considering the resulting constraints.

2.  Requirements Notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Definition CPace

3.1.  Setup

   For CPace both communication partners need to agree on a common
   cipher suite which consists of choosing a common hash function H and
   an elliptic curve group G.

   With H we denote a hash primitive with a hash function H.hash(m,l)
   that operates on an input octet string m and returns a hash result
   containing the first l result octets calculated by the primitive.

   A given hash function H is characterized by its input and its
   preferred output sizes.  We use an object-style notation
   H.constant_name.  With H.b_in_bytes we denote the preferred output
   size in bytes of the primitive such that the hash function returns
   the full length of the hash if the second length parameter is not
   given: H.hash(m) = H.hash(m, H.b_in_bytes).

   With H.bmax_in_bytes we denote the maximum output size in octets
   supported by the hash primitive.

   A first common choice for H is SHA512 [RFC6234] where b_in_bytes =
   bmax_in_bytes = 64 as a fixed-length output of 64 bytes is produced.
   Another suitable choice for H is SHAKE256 [FIPS202] which is also
   designed for a preferred length and security parameter of b_in_bytes
   = 64 but which allows for variable-length outputs without a fixed
   limit bmax_in_bytes.

   With H.s_in_bytes we denote the input block size used by H.  For
   SHA512, e.g. the input block size s_in_bytes is 128, while for
   SHAKE256 the input block size amounts to 136 bytes.

   For a given group G this document specifies how to define the
   following set of group-specific functions and constants for the
   protocol execution.  For making the implicit dependence of the
   respective functions and constants on the group G transparent, we use
   a object-style notation G.function_name() and G.constant_name.

   With G.I we denote a unique octet string representation of the
   neutral element of group G.

   g = G.calculate_generator(H, PRS,CI,sid).  With calculate_generator
   we denote a function that outputs a octet string representation of a
   group element in G which is derived from input octet strings PRS, CI,
   sid using a hash function primitive.

   y = G.sample_scalar().  This function returns an octet string
   representation of a scalar value appropriate as a private Diffie-
   Hellman key for group G.

   Y = G.scalar_mult(y,g).  This function takes a generator g as first
   parameter and a scalar y as second parameter and returns an octet
   string representation of a group element Y.

   K = G.scalar_mult_vfy(y,X).  This function returns an octet string
   representation of a group element K which is calculated from a scalar
   y and a group element X.  Moreover scalar_mult_vfy implements
   validity verifications of the inputs and returns the neutral element
   G.I if the validity check fails.

3.2.  Inputs

   With PRS we denote a password-related octet string which is a
   MANDATORY input for all CPace instantiations.  Typically PRS is
   derived from a low-entropy secret such as a user-supplied password
   (pw) or a personal identification number.

   With CI we denote an OPTIONAL octet string for the channel
   identifier.  CI can be used for binding CPace to one specific
   communication channel, if a common octet string representation for CI
   is available for both protocol partners upon protocol start.

   With sid we denote an OPTIONAL octet string input containing a
   session id.  In application scenarios where a higher-level protocol
   has established a unique sid this parameter can be used to bind the
   CPace protocol execution to one specific session.

   With ADa and ADb we denote OPTIONAL octet strings of parties A and B
   that contain associated public data of the communication partners.
   ADa could for instance include party identifiers.

3.3.  Notation

   With str1 || str2 we denote concatenation of octet strings.

   With oCAT(str1,str2) we denote ordered concatenation of octet strings
   such that oCAT(str1,str2) = str1 || str2 if str2 > str1 and
   oCAT(str1,str2) = str2 || str1 otherwise.

   CONCAT(str1,str2) defines a concatenation function that depends on
   the application scenario.  In applications where CPace is used
   without clear initiator and responder roles, i.e. where the ordering
   of messages is not enforced by the protocol flow ordered
   concatenation SHALL BE used, i.e. CONCAT(str1,str2) ==
   oCAT(str1,str2).

   In settings with defined initiator and responder roles
   CONCAT(str1,str2) SHALL BE defined as unordered concatenation:
   CONCAT(str1,str2) == str1 || str2.

   With len(S) we denote the number of octets in a string S.

   Finally, we let nil represent an empty octet string, i.e., len(nil) =
   0.

   With prepend_len(octet_string) we denote the octet sequence that is
   obtained from prepending the length of the octet string as an utf-8
   string to the byte sequence itself.  (This will prepend one single
   octet for sequences shorter than 128 bytes and more octets
   otherwise).

   With prefix_free_cat(a0,a1, ...) we denote a function that outputs
   the prefix-free encoding of all input octet strings as the
   concatenation of the individual strings with their respective length
   prepended: prepend_len(a0) || prepend_len(a1) || ... . Use of this
   function allows for a easy parsing of strings and guarantees a
   prefix-free encoding.

   With sample_random_bytes(n) we denote a function that returns n
   octets uniformly sampled between 0 and 255.  With zero_bytes(n) we
   denote a function that returns n octets with value 0.

   With ISK we denote the intermediate session key output string
   provided by CPace.  It is RECOMMENDED to convert the intermediate
   session key ISK ot a final session key by using a suitable KDF
   function prior to using the key in a higher-level protocol.

   With DSI we denote domain-separation identifier strings.

3.4.  Protocol Flow

   CPace is a one round protocol to establish an intermediate shared
   secret ISK with implicit mutual authentication.  In the setup phase
   both sides agree on a common hash function H and a group G.

   Prior to invocation, A and B are provisioned with public (CI) and
   secret information (PRS) as prerequisite for running the protocol.
   During the first round, A sends a public share Ya to B, and B
   responds with its own public share Yb.  Both A and B then derive a
   shared secret ISK.  ISK is meant to be used for producing encryption
   and authentication keys by a KDF function outside of the scope of
   CPace.

   Optionally when starting the protocol, A and B dispose of a sid
   string. sid is typically pre-established by a higher-level protocol
   invoking CPace.  If no such sid is available from a higher-level
   protocol, a suitable approach is to let A choose a fresh random sid
   string and send it to B together with the first message.  This method
   is shown in the setup protocol section below.

   This sample trace is shown below.

           A                  B
           | (setup protocol  |
   (sample sid)  |     and sid)     |
           |----------------->|
   ---------------------------------------
           |                  |
   (compute Ya)  |      Ya, ADa     |
           |----------------->|
           |      Yb, ADb     | (compute Yb)
           |<-----------------|
           |   (verify data)  |
           |   (derive ISK)   |

3.5.  CPace

   In the setup phase, both parties A,B agreed on the group G a hash H.
   If a higher-level protocol provided a session id sid, both parties
   SHALL use this value in the protocol execution.  If there is a clear
   initiator (party A) and responder (party B) role assigned in the
   application setting, A SHOULD sample a fresh random value sid and
   transmit it together with its first message.  If the application
   scenario does not enforce an ordering of the two messages and no sid
   value is available from a higher-level protocol, then the empty
   string shall be used for the session id.

   To begin, A calculates a generator g = G.calculate_generator(H,
   PRS,CI,sid).

   A samples ya = G.sample_scalar() randomly according to the
   requirements for group G.  A then calculates Ya= G.scalar_mult
   (ya,g).  A then transmits MSGa = prefix_free_cat(Ya, ADa) with Ya and
   the optional associated data ADa to B.  Note that prefixing the
   transmitted components with their respective lengths allows for
   unambigous parsing of MSGa by the receiver and guarantees a prefix-
   free encoding.

   B picks yb = G.sample_scalar() randomly.  B then calculates g =
   G.calculate_generator(H, PRS,CI,sid) and Yb = G.scalar_mult(yb,g).  B
   then calculates K = G.scalar_mult_vfy(yb,Ya).  B MUST abort if K is
   the encoding of the neutral element G.I.  Otherwise B sends MSGb =
   prefix_free_cat(Yb, ADb) to A and proceeds as follows.

   B returns ISK = H.hash(prefix_free_cat(G.DSI || "ISK", sid, K,
   CONCAT(MSGa, MSGb))).

   Upon reception of Yb, A calculates K = scalar_mult_vfy(Yb,ya).  A
   MUST abort if K is the neutral element I.  If K is different from I,
   A returns ISK = H.hash(prefix_free_cat(G.DSI || "ISK", sid, K,
   CONCAT(MSGa, MSGb))).

   Upon completion of this protocol, the session key ISK returned by A
   and B will be identical by both parties if and only if the supplied
   input parameters sid, PRS and CI match on both sides and the
   transcripts match.

   In application scenarios which are guaranteed to enforce clear
   initiator and responder roles unordered concatenation SHOULD BE used
   for the CONCAT(MSGa,MSGb) function.  In applications without enforced
   ordering of the transmission of MSGa and MSGb, CONCAT() MUST BE
   implemented by using the ordered concatenation function oCAT().

4.  Ciphersuites

   This section documents CPACE ciphersuite configurations.  A
   ciphersuite is REQUIRED to specify, - a group G with associated
   definitions for G.sample_scalar(), G.scalar_mult() and G.
   scalar_mult.vfy() and G.calculate_generator() functions and an
   associated domain separation string G.DSI. - a hash function H.

   Currently, test vectors are available for the cipher suites CPACE-
   X25519-SHA512, CPACE-X448-SHAKE256, CPACE-P256-SHA256, CPACE-
   RISTR255-SHA512, CPACE-DECAF448-SHAKE256.

5.  Use of the hash function in CPace

   With generator_string(PRS,DSI,CI,sid, H.s_in_bytes) we denote a
   function that returns a string
   prefix_free_cat(PRS,zero_bytes(len_zpad), DSI, CI, sid) in which all
   input strings are concatenated such that the encoding of PRS together
   with a suitable zero pad field completely fills the first input block
   of the hash.

   The length len_zpad of the zero padding is calculated as len_zpad =
   MAX(0, H.s_in_bytes - len(prepend_length(PRS)) - 1).

6.  CPace on single-coordinate Ladders on Montgomery curves

   In this section we consider the case of CPace using the X25519 and
   X448 Diffie-Hellman functions from [RFC7748] operating on the
   Montgomery curves Curve25519 and Curve448 [RFC7748].

   CPace implementations using single-coordinate ladders on further
   Montgomery curves SHALL use the definitions in line with the
   specifications for X25519 and X448 and review the guidance given in
   the security consideration section and [CPacePaper].

   For X25519 the following definitions apply: - G.sample_scalar() =
   sample_random_bytes(32) - G.scalar_mult(y,g) = G.scalar_mult_vfy(y,g)
   = X25519(y,g) - G.I = zero_bytes(32) - G.DSI = "CPace255" -
   G.field_size_bytes = 32 - G.field_size_bits = 255

   For X448 the following definitions apply: - G.sample_scalar() =
   sample_random_bytes(56) - G.scalar_mult(y,g) = G.scalar_mult_vfy(y,g)
   = X448(y,g) - G.I = zero_bytes(56) - G.DSI = "CPace448" -
   G.field_size_bytes = 56 - G.field_size_bits = 448

   The G.calculate_generator(H, PRS,sid,CI) function shall be
   implemented as follows. - First gen_str =
   generator_string(PRS,G.DSI,CI,sid, H.s_in_bytes) is calculated using
   the input block size of the chosen hash primitive. - This string is
   then hashed to the required length gen_str_hash = H.hash(gen_str,
   G.field_size_bytes).  Note that this implies that the permissible
   output length H.maxb_in_bytes MUST BE larger or equal to the field
   size of the group G for making a hashing primitive suitable. - This
   result is then considered as a field coordinate using the u =
   decodeUCoordinate(gen_str_hash, G.field_size_bits) function from
   [RFC7748] which we repeat in the appendix for convenience. - The
   result point g is then calculated as (g,v) =
   map_to_curve_elligator2(u) using the function from
   [I-D.irtf-cfrg-hash-to-curve].  Note that the v coordinate produced
   by the map_to_curve_elligator2 function is not required for CPace and
   discarded.

   In the appendix we show sage code that can be used as reference
   implementation for the calculate_generator and key generation
   functions.

   The definitions above aim at making the protocol suitable for
   outsourcing CPace to secure elements (SE) where nested hash function
   constructions such as defined in [RFC5869] have to be considered to
   be particularly costly.  Moreover as all hash operations are executed
   using strings with a prefix-free encoding also Merkle-Damgard
   constructions such as the SHA2 family can be considered as a
   representation of a random oracle, given that the permutation
   function is considered as a random oracle.

   Finally, with the introduction of a zero-padding after the PRS
   string, the CPace design aims at mitigating attacks of a side-channel
   adversary that analyzes correlations between publicly known
   information with the low-entropy PRS string.

7.  CPace on prime-order group abstractions

   In this section we consider the case of CPace using the
   ristretto25519 and decafX448 group abstractions.  These abstractions
   define an encode and decode function, group exponentiation and a one-
   way-map.

   For ristretto255 the following definitions apply: - G.DSI =
   "CPaceRistretto" - G.field_size_bytes = 32 - G.group_size_bits = 252

   For decaf448 the following definitions apply: - G.DSI = "CPaceDecaf"
   - G.field_size_bytes = 56 - G.group_size_bits = 488

   For both abstractions the following definitions apply: -
   G.sample_scalar() = sample_random_bytes(G.group_size_bits) (Todo: add
   masking the upper bits!). - G.scalar_mult(y,g) = encode(g^y) - G.I =
   encode(g^0), where g is an arbitrary generator -
   G.scalar_mult_vfy(y,X) is implemented as follows.  If the decode(X)
   function fails, it returns G.I.  Otherwise it returns encode(
   decode(X)^y )

   Note that with these definitions the scalar_mult function operates on
   a decoded point g and returns an encoded point, while the
   scalar_mult_vfy(y,X) function operates on a scalar and an encoded
   point X.

   The G.calculate_generator(H, PRS,sid,CI) function shall return a
   decoded point and be implemented as follows. - First gen_str =
   generator_string(PRS,G.DSI,CI,sid, H.s_in_bytes) is calculated using
   the input block size of the chosen hash primitive. - This string is
   then hashed to the required length gen_str_hash = H.hash(gen_str, 2 *
   G.field_size_bytes).  Note that this implies that the permissible
   output length H.maxb_in_bytes MUST BE larger or equal to twice the
   field size of the group G for making a hashing primitive suitable.
   Finally the generator g is calculated as g =
   one_way_map(gen_str_hash) using the one-way map function from the
   abstraction.

8.  Security Considerations

   A security proof of CPace is found in [CPacePaper].

   In order to prevent length-extension attacks, all hash inputs MUST be
   prefix-free strings in order to make CPace suitable when Merkle-
   Damgard hashing constructions such as SHA2 or SHA512 are considered
   [CDMP05].  Otherwise so-called length-extension attacks of the hash
   would have to be considered.  This is guaranteed by the design of the
   prefix_free_cat() function.

   Although already K is a shared value, still it MUST NOT be used as a
   shared secret key.  Note that calculation of ISK from K includes the
   protocol transcript and prevents key malleability with respect to
   man-in-the-middle attacks from active adversaries.

   The definitions given for the case of Curve25519 and Curve448 rely on
   the following properties of the elliptic curves [CPacePaper]: - The
   curve has order (p * c) with p prime and c a small cofactor.  Also
   the curve's quadratic twist must be of order (p' * c') with p' prime
   and c' a cofactor. - The cofactor c' of the twist MUST BE EQUAL to or
   an integer multiple of the cofactor c of the curve. - The
   representation of the neutral element G.I MUST BE the same for both,
   the curve and its twist. - Both field order q and group order p are
   close to a power of two such that randomly sampled binary strings can
   be used as representation for field elements and scalars [CPacePaper]
   .

   Elements received from a peer MUST be checked by a proper
   implementation of the scalar_mult_vfy methods.  Failure to properly
   validate group elements can lead to attacks.  The Curve25519-based
   cipher suite employs the twist security feature of the curve for
   point validation.  As such, it is mandatory to check that any actual
   X25519 function implementation maps all low-order points on both the
   curve and the twist on the neutral element.  Corresponding test
   vectors are provided in the appendix.

   The randomly generated values ya and yb MUST NOT be reused.

   CPace is not originally meant to be used in conjunction with servers
   supporting several users and, thus several different username/
   password pairs.  In this setting it is RECOMMENDED to consider the
   augmented PAKE protocol OPAQUE or to use CPace as building block of
   the augmented AuCPace protocol [AUCPacePaper].

   If CPace is used as a building block of higher-level protocols, it is
   RECOMMENDED that sid is generated by the higher-level protocol and
   passed to CPace.  One suitable option is that sid is generated by
   concatenating ephemeral random strings from both parties.

   Since CPace is designed to be used as a building block in higher-
   level protocols and for compatibility with constrained hardware, it
   does not by itself include a strong key derivation function
   construction.  Instead CPace uses a simple hash operation on a
   prefix-free string input for generating its intermediate key ISK.  It
   is RECOMMENDED that the ISK is post-processed by a KDF such as
   [RFC5869] according the needs of the higher-level protocol.  In case
   that the CPace protocol is delegated to a secure element hardware, it
   is RECOMMENDED that the calculation of the KDF function is
   implemented in the main processing unit.

   In case that side-channel attacks are to be considered practical for
   a given application, it is RECOMMENDED to focus side-channel
   protections such as masking and redundant execution (faults) on the
   process of calculating the secret generator
   G.calculate_generator(PRS,CI,sid).  The most critical aspect to
   consider is the processing of the first block of the hash that
   includes the PRS string.  The CPace protocol construction considers
   the fact that side-channel protections of hash functions might be
   particularly resource hungry.  For this reason, CPace aims at
   minimizing the number of hash functions invocations in the specified
   calculate_generator function.

   CPace is proven secure under the hardness of the computational
   Simultaneous Diffie-Hellmann (SDH) assumption in the group G (as
   defined in [CPacePaper]).  Still, even for the event that large-scale
   quantum computers (LSQC) will become available, CPace forces an
   active adversary to solve one CDH per password guess [CPacePaper2].
   In this sense, using the wording suggested by Steve Thomas on the
   CFRG mailing list, CPace is "quantum-annoying".

   While the zero-padding introduced when hashing the sensitive PRS
   string can be expected to make the task for a side-channel adversary
   more complex, this feature allone is not sufficient for preventing
   power analysis attacks.

9.  IANA Considerations

   No IANA action is required.

10.  Acknowledgements

   Thanks to the members of the CFRG for comments and advice.  Any
   comment and advice is appreciated.

   Comments are specifically invited regarding the inclusion or
   exclusion of both, initiator/responder and symmetric settings.
   Currently we plan to consider both application settings in this
   draft.

11.  References

11.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

11.2.  Informative References

   [AUCPacePaper]
              Haase, B. and B. Labrique, "AuCPace. PAKE protocol
              tailored for the use in the internet of things", February
              2018, <https://eprint.iacr.org/2018/286>.

   [CDMP05]   Coron, J-S., Dodis, Y., Malinaud, C., and P. Puniya,
              "Merkle-Damgaard Revisited: How to Construct a Hash
              Function", In Advances in Cryptology - CRYPTO 2005,
              pages 430-448, DOI 10.1007/11535218_26, 2005,
              <https://doi.org/10.1007/11535218_26>.

   [CPacePaper]
              Abdalla, M., Haase, B., and J. Hesse, "Security analysis
              of CPace", n.d., <https://eprint.iacr.org/2021/114>.

   [CPacePaper2]
              Eaton, E. and D. Stebila, "The 'quantum annoying' property
              of password-authenticated key exchange protocols.", n.d.,
              <https://eprint.iacr.org/2021/696>.

   [FIPS202]  National Institute of Standards and Technology (NIST),
              "SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", August 2015,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.202.pdf>.

   [I-D.irtf-cfrg-hash-to-curve]
              Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R. S.,
              and C. A. Wood, "Hashing to Elliptic Curves", Work in
              Progress, Internet-Draft, draft-irtf-cfrg-hash-to-curve-
              12, 16 September 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              hash-to-curve-12>.

   [NonceDisrespecting]
              Bock, H., Zauner, A., Devlin, S., Somorovsky, J., and P.
              Jovanovic, "Nonce-Disrespecting Adversaries -- Practical
              Forgery Attacks on GCM in TLS", 17 May 2016,
              <https://eprint.iacr.org/2016/475.pdf>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/rfc/rfc5869>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/rfc/rfc6234>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/rfc/rfc7748>.

Authors' Addresses

   Michel Abdalla
   DI, École Normale Supérieure, Paris

   Email: michel.abdalla@ens.fr


   Bjoern Haase
   Endress + Hauser Liquid Analysis

   Email: bjoern.m.haase@web.de


   Julia Hesse
   IBM, Zürich Research Laboratory

   Email: JHS@zurich.ibm.com
